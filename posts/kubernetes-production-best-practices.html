<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Kubernetes in Production: 10 Lessons Learned — Hard-won insights from running K8s clusters at scale.">
  <title>Kubernetes in Production: 10 Lessons Learned | Jenella Awo</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body><script>if(localStorage.getItem('theme')==='light')document.body.classList.add('light-mode')</script>

  <!-- READING PROGRESS -->
  <div class="reading-progress"></div>

  <!-- NAVIGATION -->
  <nav class="navbar" id="navbar">
    <div class="nav-container">
      <a href="../index.html" class="nav-logo">&lt;JA /&gt;</a>
      <ul class="nav-menu" id="nav-menu">
        <li><a href="../index.html" class="nav-link">Home</a></li>
        <li><a href="../about.html" class="nav-link">About</a></li>
        <li><a href="../skills.html" class="nav-link">Skills</a></li>
        <li><a href="../projects.html" class="nav-link">Projects</a></li>
        <li><a href="../experience.html" class="nav-link">Experience</a></li>
        <li><a href="../contact.html" class="nav-link">Contact</a></li>
        <li><a href="../blog.html" class="nav-link">Blog</a></li>
      </ul>
      <button class="theme-toggle" aria-label="Toggle theme">&#9790;</button>
      <a href="../contact.html" class="nav-cta">Hire Me</a>
      <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
        <span></span><span></span><span></span>
      </button>
    </div>
  </nav>

  <!-- POST -->
  <section class="section" style="padding-top: 140px;">
    <div class="container">
      <a href="../blog.html" class="post-back">&#8592; Back to Blog</a>

      <div class="post-header">
        <h1>Kubernetes in Production: 10 Lessons Learned</h1>
        <div class="post-meta">
          <span>Feb 12, 2026</span>
          <span>8 min read</span>
          <span class="tag">Kubernetes</span>
          <span class="tag">EKS</span>
          <span class="tag">Production</span>
        </div>
      </div>

      <div class="post-body">
        <p>Running Kubernetes in development is straightforward. Running it in production — with real traffic, real SLAs, and real on-call rotations — is a different game entirely. After managing production EKS and AKS clusters serving millions of requests, here are the ten lessons that cost me the most sleep before I learned them.</p>

        <h2>1. Always Set Resource Requests and Limits</h2>
        <p>This is the single most impactful thing you can do for cluster stability. Without resource requests, the scheduler has no idea where to place pods. Without limits, a single runaway process can starve an entire node. I set requests based on the p95 usage from monitoring data and limits at 2x the request as a starting point, then tune from there.</p>

        <h2>2. Use Pod Disruption Budgets</h2>
        <p>PodDisruptionBudgets (PDBs) prevent Kubernetes from evicting too many pods simultaneously during node upgrades or maintenance. Without them, a rolling node update can take down your entire service. I set <code>minAvailable: 50%</code> as a baseline for all production deployments.</p>

        <h2>3. Implement Proper Health Checks</h2>
        <p>Liveness probes tell Kubernetes when to restart a container. Readiness probes tell it when a pod is ready to receive traffic. Getting these wrong is one of the most common causes of production incidents. A misconfigured liveness probe that's too aggressive will cause restart loops. A missing readiness probe will send traffic to pods that aren't ready, causing 5xx errors.</p>
        <p>My pattern: readiness probes check the actual application health endpoint, liveness probes check a simpler "is the process alive" endpoint, and startup probes give slow-starting applications time to initialize before liveness kicks in.</p>

        <h2>4. Don't Skip Network Policies</h2>
        <p>By default, every pod in a Kubernetes cluster can communicate with every other pod. In production, this is a security risk. I implement <strong>deny-all-by-default</strong> network policies and explicitly allow only the traffic flows that should exist. This follows the principle of least privilege at the network layer.</p>

        <h2>5. Namespace Isolation Is Not Optional</h2>
        <p>I use namespaces to isolate teams, environments, and workloads. Combined with <strong>ResourceQuotas</strong> and <strong>LimitRanges</strong>, namespaces prevent any single team from monopolizing cluster resources. Each namespace gets a resource quota proportional to its SLA requirements.</p>

        <h2>6. Invest in Observability Early</h2>
        <p>You cannot operate what you cannot observe. Before deploying production workloads, I set up the observability trifecta: <strong>metrics</strong> (Prometheus + Grafana), <strong>logs</strong> (Fluent Bit to CloudWatch or Loki), and <strong>traces</strong> (OpenTelemetry to Jaeger or X-Ray). The cost of setting this up before production is a fraction of the cost of debugging blind during an incident.</p>

        <h2>7. Automate Everything with GitOps</h2>
        <p>Manual <code>kubectl apply</code> commands in production are a recipe for drift and outages. I use <strong>ArgoCD</strong> with a GitOps workflow where the Git repository is the single source of truth. Every change goes through a PR, gets reviewed, and ArgoCD syncs the desired state to the cluster automatically. This gives you an audit trail, rollback capability, and eliminates "it worked on my machine" deployments.</p>

        <h2>8. Plan for Node Failures</h2>
        <p>Nodes will fail. EBS volumes will detach. AWS availability zones will have issues. Design for it. I run workloads across multiple AZs with <strong>topology spread constraints</strong>, use <strong>pod anti-affinity</strong> rules to spread replicas, and configure the <strong>Cluster Autoscaler</strong> with multiple instance types and purchase options to handle capacity changes gracefully.</p>

        <h2>9. Secrets Management Matters</h2>
        <p>Kubernetes Secrets are base64-encoded, not encrypted. For production, I use <strong>AWS Secrets Manager</strong> or <strong>HashiCorp Vault</strong> with the <strong>External Secrets Operator</strong> to inject secrets at runtime. This keeps sensitive data out of Git, provides rotation capabilities, and gives you a centralized audit trail of secret access.</p>

        <h2>10. Practice Failure Regularly</h2>
        <p>The worst time to discover that your failover doesn't work is during an actual outage. I run regular <strong>chaos engineering</strong> experiments — killing pods, draining nodes, simulating AZ failures — during business hours with the team watching. Tools like <strong>Litmus Chaos</strong> and <strong>AWS Fault Injection Simulator</strong> make this repeatable and safe. Every experiment that reveals a weakness is a production incident prevented.</p>

        <h2>Final Thought</h2>
        <p>Kubernetes is powerful, but it's not magic. It amplifies both good practices and bad ones. Invest in the fundamentals — resource management, observability, security, and automation — before chasing the latest service mesh or operator pattern. The boring stuff is what keeps your cluster running at 3 AM.</p>
      </div>
    </div>
  </section>

  <!-- FOOTER -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <p class="footer-logo">&lt;JA /&gt;</p>
        <p>&copy; 2026 Jenella Awo. All rights reserved.</p>
        <div class="footer-socials">
          <a href="https://www.linkedin.com/in/jenella-v-4a4b963ab/" target="_blank" rel="noopener" aria-label="LinkedIn">in</a>
          <a href="https://github.com/vanessa9373" target="_blank" rel="noopener" aria-label="GitHub">gh</a>
          <a href="mailto:vanessa93730@gmail.com" aria-label="Email">@</a>
        </div>
      </div>
    </div>
  </footer>

  <button class="back-to-top" id="back-to-top" aria-label="Back to top">&#8593;</button>
  <script src="../script.js"></script>
</body>
</html>
