<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Designing Reusable Terraform Modules at Scale — Patterns for building Terraform modules your team will actually use.">
  <title>Designing Reusable Terraform Modules at Scale | Jenella Awo</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body><script>if(localStorage.getItem('theme')==='light')document.body.classList.add('light-mode')</script>

  <!-- READING PROGRESS -->
  <div class="reading-progress"></div>

  <!-- NAVIGATION -->
  <nav class="navbar" id="navbar">
    <div class="nav-container">
      <a href="../index.html" class="nav-logo">&lt;JA /&gt;</a>
      <ul class="nav-menu" id="nav-menu">
        <li><a href="../index.html" class="nav-link">Home</a></li>
        <li><a href="../about.html" class="nav-link">About</a></li>
        <li><a href="../skills.html" class="nav-link">Skills</a></li>
        <li><a href="../projects.html" class="nav-link">Projects</a></li>
        <li><a href="../experience.html" class="nav-link">Experience</a></li>
        <li><a href="../contact.html" class="nav-link">Contact</a></li>
        <li><a href="../blog.html" class="nav-link">Blog</a></li>
      </ul>
      <button class="theme-toggle" aria-label="Toggle theme"><svg class="icon" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg></button>
      <a href="../contact.html" class="nav-cta">Hire Me</a>
      <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">
        <span></span><span></span><span></span>
      </button>
    </div>
  </nav>

  <!-- POST -->
  <section class="section" style="padding-top: 140px;">
    <div class="container">
      <a href="../blog.html" class="post-back"><svg class="icon icon-sm" viewBox="0 0 24 24"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg> Back to Blog</a>

      <div class="post-header">
        <h1>Designing Reusable Terraform Modules at Scale</h1>
        <div class="post-meta">
          <span>Jan 28, 2026</span>
          <span>7 min read</span>
          <span class="tag">Terraform</span>
          <span class="tag">IaC</span>
          <span class="tag">Modules</span>
        </div>
      </div>

      <div class="post-body">
        <p>Terraform modules are the building blocks of infrastructure as code at scale. Done right, they eliminate duplication, enforce standards, and let teams self-service infrastructure in minutes. Done wrong, they become an unmaintainable maze of spaghetti HCL that nobody wants to touch. After building a 40+ module library used across multiple client engagements, here's how I approach module design.</p>

        <h2>Principle 1: One Module, One Purpose</h2>
        <p>The most common mistake is building "god modules" that try to do everything. A module that creates a VPC, subnets, NAT gateways, route tables, security groups, and an EKS cluster is too large. When something breaks, you can't reason about it. When requirements change, you're afraid to touch it.</p>
        <p>I follow the Unix philosophy: each module does one thing well. My VPC module creates networking. My EKS module consumes the VPC outputs and creates the cluster. My RDS module takes subnet IDs and security group IDs as inputs. They compose together cleanly because their boundaries are clear.</p>

        <h2>Principle 2: Sensible Defaults, Full Override</h2>
        <p>Good modules work out of the box with zero configuration but let power users customize everything. I achieve this with default variable values that encode best practices:</p>
        <pre><code>variable "instance_class" {
  description = "RDS instance class"
  type        = string
  default     = "db.t3.medium"
}

variable "multi_az" {
  description = "Enable Multi-AZ deployment"
  type        = bool
  default     = true
}

variable "backup_retention_period" {
  description = "Days to retain backups"
  type        = number
  default     = 7
}</code></pre>
        <p>A new team can use the module with just a database name and credentials. An experienced team can override instance class, enable cross-region replicas, or customize parameter groups without forking the module.</p>

        <h2>Principle 3: Consistent Naming and Tagging</h2>
        <p>Every module should enforce a consistent naming convention and tagging strategy. I pass a <code>context</code> object through all modules that includes environment, project, team, and cost center:</p>
        <pre><code>module "vpc" {
  source = "./modules/vpc"
  context = {
    environment = "production"
    project     = "payments"
    team        = "platform"
    cost_center = "eng-001"
  }
}</code></pre>
        <p>Inside each module, resources are named using this context: <code>${context.project}-${context.environment}-vpc</code>. Tags are applied automatically. This consistency makes cost allocation, access control, and cleanup straightforward across hundreds of resources.</p>

        <h2>Principle 4: Test Everything</h2>
        <p>Untested modules are time bombs. I use a three-layer testing strategy:</p>
        <ul>
          <li><strong>Static analysis:</strong> <code>terraform validate</code>, <code>tflint</code>, and <code>checkov</code> run on every PR to catch syntax errors, best-practice violations, and security issues before anything gets deployed.</li>
          <li><strong>Unit tests:</strong> <strong>Terratest</strong> (Go) or <strong>pytest-terraform</strong> deploys the module to a sandbox account, validates the outputs and resource configurations, then tears everything down. Each module has its own test suite.</li>
          <li><strong>Integration tests:</strong> Composition tests deploy multiple modules together (VPC + EKS + RDS) to validate they work as a system. These run nightly or before major releases.</li>
        </ul>
        <p>The CI pipeline runs static analysis on every commit, unit tests on every PR, and integration tests on merges to main. This catches breaking changes before they reach production.</p>

        <h2>Principle 5: Version and Document</h2>
        <p>Modules should be versioned semantically (major.minor.patch) and published to a private registry. Consumers pin to specific versions so that module updates don't break their infrastructure unexpectedly:</p>
        <pre><code>module "vpc" {
  source  = "app.terraform.io/acme/vpc/aws"
  version = "~> 2.1"
}</code></pre>
        <p>Each module includes a <code>README.md</code> generated by <strong>terraform-docs</strong> with input/output descriptions, usage examples, and architecture notes. I've found that if a module doesn't have a clear example, engineers will either use it wrong or build their own — neither outcome is good.</p>

        <h2>Principle 6: State Isolation</h2>
        <p>Never store all your infrastructure in a single state file. I organize state by environment and by service boundary. Each module invocation gets its own state file in S3 with DynamoDB locking:</p>
        <pre><code>backend "s3" {
  bucket         = "acme-terraform-state"
  key            = "production/vpc/terraform.tfstate"
  region         = "us-east-1"
  dynamodb_table = "terraform-locks"
  encrypt        = true
}</code></pre>
        <p>This means a broken state for the VPC doesn't block deployments to EKS, and different teams can work on different services without stepping on each other's state locks.</p>

        <h2>Putting It All Together</h2>
        <p>A well-designed module library transforms infrastructure provisioning from a weeks-long process into a 30-minute self-service operation. The investment in testing, documentation, and versioning pays for itself many times over in reduced toil, fewer misconfigurations, and faster onboarding for new team members. Start small, iterate often, and resist the urge to abstract before you have at least three concrete use cases.</p>
      </div>
    </div>
  </section>

  <!-- FOOTER -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <p class="footer-logo">&lt;JA /&gt;</p>
        <p>&copy; 2026 Jenella Awo. All rights reserved.</p>
        <div class="footer-socials">
          <a href="https://www.linkedin.com/in/jenella-v-4a4b963ab/" target="_blank" rel="noopener" aria-label="LinkedIn"><svg class="icon" viewBox="0 0 24 24"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a>
          <a href="https://github.com/vanessa9373" target="_blank" rel="noopener" aria-label="GitHub"><svg class="icon" viewBox="0 0 24 24"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/></svg></a>
          <a href="mailto:vanessa93730@gmail.com" aria-label="Email"><svg class="icon" viewBox="0 0 24 24"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a>
        </div>
      </div>
    </div>
  </footer>

  <button class="back-to-top" id="back-to-top" aria-label="Back to top"><svg class="icon" viewBox="0 0 24 24"><polyline points="18 15 12 9 6 15"/></svg></button>
  <script src="../script.js"></script>
</body>
</html>
